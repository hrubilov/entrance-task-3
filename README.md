# Решение 3-го вступительного задания

Итак, начнем с конца.

1. По всей видимости, после рефакторинга "Разложить файлы красиво" файлы разложились красиво, но неправильно. А именно, файл service-worker.js, зачем-то, был перемещен в каталог assets. В файле `blocks.js` на строке 469 происходит его регистрация: 

`.register('./assets/service-worker.js')`, 

в силу чего, область видимости ServiceWorker изменилась и он перестал обрабатывать события ресурсов приложения и самого файла `gifs.html`, находящегося в корневой папке. Для исправления ситуации, нужно вернуть файл service-worker.js в корневую папку и изменить строку его регистрации в файле `block.js` на:

`.register('./service-worker.js')`. 

2. После того, как мы вернули файл `service-worker.js` туда, где ему положено было быть, в кэш стали сохраняться статические файлы из директорий `vendor` и `assets`. Html-страница же в кэш не пишется и, соответственно, оффлайн-режим не работает. Действительно, если взглянуть на функцию `needStoreForOffline()`, которая определяет неободимость сохранения скачанного ресурса в кэше, то мы увидим, что в функции отсутствует проверка на ресурс `'gifs.html'`, что объясняет отличие в поведении html-файла от статических ресурсов из директорий `vendor` и `assets`. Кроме этого, проблема невозможности обновления статики наводит на мысль о том, что неверно принимается решение о том, скачивать ли нам файл, либо, в случае провала, брать его из кэша. Добавив поиск подстроки `'gifs.html'` (а не просто `'./'`, чтобы не кэшировать сам ServiceWorker) в функцию `needStoreForOffline()`, мы убеждаемся, что оффлайн-режим заработал (html-страница теперь пишется в кэш), но файл `gifs.html`, так же, как и остальную статику, стало невозможно обновить.

3. Учитывая все это, мы обратимся к обработчику события `fetch`, в котором принимается решение откуда нам брать ресурс. 
```
if (needStoreForOffline(cacheKey)) { 
    response = caches.match(cacheKey)     
      .then(cacheResponse => cacheResponse || fetchAndPutToCache(cacheKey, event.request));        
    } else {
        response = fetchWithFallbackToCache(event.request);
}
```
Из этих строк становится ясно, что если местоположение ресурса указывает на то, что его нужно сохранить в кэше, то ресурс ищется в кэше, при помощи функции `caches.match(cacheKey)`. В случае успешного нахождения файла, промис, возвращаемый функцией `caches.match()` резолвится в респонс c файлом из кэша или, если `cacheResponse` равен `undefined` (ресурс не найден), вызывать функцию скачивания ресурса `fetchAndPutToCache(cacheKey, event.request)`. Именно поэтому, закэшировавшись один раз, файлы постоянно берутся из кэша. Решить проблему можно заменив вышеприведенный код на:

`response = fetchAndPutToCache(cacheKey, event.request); `

При этом функция `fetchAndPutToCache()` уже содержит в себе обработчик `.catch`, который в случае неудачной попытки скачивания ресурса вернет соответствующий промис от функции `caches.match()`. 

В результате данных манипуляций, приложение вновь обрело работоспособное состояние. :tada:
